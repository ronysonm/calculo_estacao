---
phase: 01-foundation
plan: 03
type: tdd
wave: 3
depends_on: ["01-02"]
files_modified:
  - src/domain/calculations/dateEngine.ts
  - src/domain/calculations/dateEngine.test.ts
  - src/domain/calculations/index.ts
autonomous: true

must_haves:
  truths:
    - "calculateManejoDate correctly computes a single manejo date from D0 + day offset + round offset"
    - "calculateProtocolDates returns all manejo dates for a protocol across all rounds"
    - "calculateLotSchedule produces the complete schedule for a lot (all rounds, all manejos)"
    - "Date engine handles December 31 + N days crossing into new year correctly"
    - "Date engine handles leap year February 28/29 transitions correctly"
    - "Date engine handles month boundary crossings correctly"
    - "Multiple rounds calculate with correct interval spacing (default 22 days, configurable)"
  artifacts:
    - path: "src/domain/calculations/dateEngine.ts"
      provides: "Pure date calculation functions for IATF manejo scheduling"
      exports: ["calculateManejoDate", "calculateProtocolDates", "calculateLotSchedule"]
      min_lines: 40
    - path: "src/domain/calculations/dateEngine.test.ts"
      provides: "Comprehensive tests for date engine including edge cases"
      contains: "describe.*dateEngine"
      min_lines: 80
    - path: "src/domain/calculations/index.ts"
      provides: "Barrel export for calculations module"
      exports: ["calculateManejoDate", "calculateProtocolDates", "calculateLotSchedule"]
  key_links:
    - from: "src/domain/calculations/dateEngine.ts"
      to: "date-fns"
      via: "addDays import for all date arithmetic"
      pattern: "import.*addDays.*from.*date-fns"
    - from: "src/domain/calculations/dateEngine.ts"
      to: "src/domain/models/Protocol.ts"
      via: "Protocol type for protocol.days access"
      pattern: "import.*Protocol.*from"
    - from: "src/domain/calculations/dateEngine.ts"
      to: "src/domain/models/Lot.ts"
      via: "Lot type for lot schedule calculation"
      pattern: "import.*Lot.*from"
---

<objective>
Build the bulletproof date calculation engine using TDD (Red-Green-Refactor). This is the core logic of the entire application — every manejo date the user sees flows through these functions. Getting edge cases wrong means wrong dates on the field.

Purpose: TDD ensures the date engine handles all edge cases (leap years, month boundaries, year crossings) correctly before any UI touches it. The tests serve as living documentation of expected behavior.
Output: Fully tested date calculation engine with 100% edge case coverage.
</objective>

<execution_context>
@/home/suporte/.claude/get-shit-done/workflows/execute-plan.md
@/home/suporte/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-02-SUMMARY.md
</context>

<feature>
  <name>Date Calculation Engine</name>
  <files>src/domain/calculations/dateEngine.ts, src/domain/calculations/dateEngine.test.ts, src/domain/calculations/index.ts</files>
  <behavior>
    The date engine calculates manejo dates for IATF breeding protocols. All functions are pure (no side effects, no state).

    **Function 1: calculateManejoDate(d0: Date, dayOffset: number, roundIndex: number, roundInterval: number): Date**
    - Calculates a single manejo date
    - roundIndex 0 = first round (A1), roundIndex 1 = A2, etc.
    - Formula: addDays(d0, (roundIndex * roundInterval) + dayOffset)
    - Uses date-fns addDays exclusively (NEVER manual date arithmetic)

    Cases:
    - d0=Jan 15 2024, dayOffset=7, roundIndex=0, interval=22 -> Jan 22 2024
    - d0=Jan 15 2024, dayOffset=9, roundIndex=0, interval=22 -> Jan 24 2024
    - d0=Jan 15 2024, dayOffset=0, roundIndex=1, interval=22 -> Feb 6 2024
    - d0=Jan 15 2024, dayOffset=7, roundIndex=1, interval=22 -> Feb 13 2024
    - d0=Jan 15 2024, dayOffset=9, roundIndex=3, interval=22 -> Apr 2 2024
    - d0=Dec 25 2024, dayOffset=9, roundIndex=0, interval=22 -> Jan 3 2025 (year crossing)
    - d0=Feb 20 2024, dayOffset=9, roundIndex=0, interval=22 -> Feb 29 2024 (leap year)
    - d0=Feb 20 2023, dayOffset=9, roundIndex=0, interval=22 -> Mar 1 2023 (non-leap year)
    - d0=Jan 31 2024, dayOffset=0, roundIndex=1, interval=22 -> Feb 22 2024 (month boundary)
    - d0=Dec 31 2024, dayOffset=1, roundIndex=0, interval=22 -> Jan 1 2025

    **Function 2: calculateProtocolDates(d0: Date, protocol: Protocol, roundCount: number, roundInterval: number): ManejoDate[]**
    - Returns array of ManejoDate objects for all rounds of a protocol
    - ManejoDate = { day: number, date: Date, roundLabel: string }
    - For protocol D0-D7-D9 with 4 rounds: returns 12 ManejoDate objects (3 manejos x 4 rounds)
    - Results ordered by round then by day within round

    Cases:
    - D0-D7-D9, d0=Jan 1 2024, 2 rounds, interval=22:
      -> [D0 Jan 1, D7 Jan 8, D9 Jan 10, D0 Jan 23, D7 Jan 30, D9 Feb 1]
    - D0-D8-D10, d0=Jan 1 2024, 1 round, interval=22:
      -> [D0 Jan 1, D8 Jan 9, D10 Jan 11]
    - D0-D7-D9, d0=Jan 1 2024, 4 rounds, interval=22:
      -> 12 results total, last D9 = addDays(Jan 1, 3*22+9) = Apr 5 2024

    **Function 3: calculateLotSchedule(lot: Lot, protocol: Protocol, roundCount: number): ManejoDate[]**
    - Convenience function combining lot.d0, lot.roundInterval with calculateProtocolDates
    - Uses lot.roundInterval (per-lot interval per user decision)

    Cases:
    - Lot with d0=Jan 15, interval=25, protocol D0-D7-D9, 4 rounds:
      -> Uses 25-day interval instead of default 22
    - Lot with d0=Jan 15, interval=22, protocol D0-D8-D10, 2 rounds:
      -> 6 results, correct D8/D10 offsets

    **Edge cases to test:**
    - December 31 + various offsets crossing into January
    - February 28 in leap year (2024) + 1 day = Feb 29
    - February 28 in non-leap year (2023) + 1 day = Mar 1
    - Large round intervals (e.g., 30 days) with 6 rounds spanning months
    - Round interval of 1 day (extreme but allowed per user decision)
    - dayOffset of 0 (D0 manejo itself)
    - Single round (count=1)
    - Maximum rounds (count=6)
  </behavior>
  <implementation>
    **RED phase:**
    1. Create src/domain/calculations/dateEngine.test.ts
    2. Write tests for calculateManejoDate covering:
       - Basic calculation (standard protocol days)
       - Year crossing (December -> January)
       - Leap year (Feb 28/29)
       - Non-leap year (Feb 28 -> Mar 1)
       - Month boundaries
       - Multiple rounds with varying intervals
    3. Write tests for calculateProtocolDates covering:
       - Correct number of results (3 manejos x N rounds)
       - Correct round labels (A1, A2, etc.)
       - Ordered results (by round, then by day)
    4. Write tests for calculateLotSchedule covering:
       - Uses lot-specific interval
       - Delegates to calculateProtocolDates correctly
    5. Run tests — ALL MUST FAIL (red)
    6. Commit: test(01-03): add failing tests for date calculation engine

    **GREEN phase:**
    1. Create src/domain/calculations/dateEngine.ts
    2. Define ManejoDate interface: { readonly day: number, readonly date: Date, readonly roundLabel: string }
    3. Implement calculateManejoDate using date-fns addDays:
       ```typescript
       import { addDays } from 'date-fns';
       export const calculateManejoDate = (d0: Date, dayOffset: number, roundIndex: number, roundInterval: number): Date => {
         return addDays(d0, (roundIndex * roundInterval) + dayOffset);
       };
       ```
    4. Implement calculateProtocolDates iterating rounds and protocol.days
    5. Implement calculateLotSchedule as wrapper
    6. Create src/domain/calculations/index.ts barrel export
    7. Run tests — ALL MUST PASS (green)
    8. Commit: feat(01-03): implement date calculation engine

    **REFACTOR phase (if needed):**
    1. Clean up any code smells
    2. Ensure all functions are pure (no side effects)
    3. Run tests — still pass
    4. Commit: refactor(01-03): clean up date engine
  </implementation>
</feature>

<verification>
1. `npm test -- --run` passes ALL tests (edge cases included)
2. `npm run type-check` passes with dateEngine exports
3. Test count >= 15 (covering all specified edge cases)
4. All 3 exported functions work correctly
5. No manual date arithmetic — only date-fns addDays used
</verification>

<success_criteria>
- calculateManejoDate produces correct dates for all edge cases (year crossing, leap year, month boundary)
- calculateProtocolDates returns 3*N ManejoDate objects for N rounds, correctly ordered
- calculateLotSchedule uses per-lot interval from Lot object
- All tests pass with zero failures
- Functions are pure — no side effects, no state mutation
- date-fns addDays is the sole source of date arithmetic
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-03-SUMMARY.md`
</output>
