---
phase: 01-foundation
plan: 03
type: tdd
wave: 3
depends_on: ["01-02"]
files_modified:
  - src/domain/calculations/dateEngine.ts
  - src/domain/calculations/dateEngine.test.ts
  - src/domain/calculations/index.ts
autonomous: true

must_haves:
  truths:
    - "calculateManejoDate correctly computes a single manejo date from D0 + day offset + round offset"
    - "calculateProtocolDates returns all manejo dates for a protocol across all rounds"
    - "calculateLotSchedule produces the complete schedule for a lot (all rounds, all manejos)"
    - "Date engine handles December 31 + N days crossing into new year correctly"
    - "Date engine handles leap year February 28/29 transitions correctly"
    - "Date engine handles month boundary crossings correctly"
    - "Multiple rounds calculate with correct interval spacing (default 22 days, configurable)"
  artifacts:
    - path: "src/domain/calculations/dateEngine.ts"
      provides: "Pure date calculation functions for IATF manejo scheduling"
      exports: ["calculateManejoDate", "calculateProtocolDates", "calculateLotSchedule"]
      min_lines: 40
    - path: "src/domain/calculations/dateEngine.test.ts"
      provides: "Comprehensive tests for date engine including edge cases"
      contains: "describe.*dateEngine"
      min_lines: 80
    - path: "src/domain/calculations/index.ts"
      provides: "Barrel export for calculations module"
      exports: ["calculateManejoDate", "calculateProtocolDates", "calculateLotSchedule"]
  key_links:
    - from: "src/domain/calculations/dateEngine.ts"
      to: "date-fns"
      via: "addDays import for all date arithmetic"
      pattern: "import.*addDays.*from.*date-fns"
    - from: "src/domain/calculations/dateEngine.ts"
      to: "src/domain/models/Protocol.ts"
      via: "Protocol type for protocol.days access"
      pattern: "import.*Protocol.*from"
    - from: "src/domain/calculations/dateEngine.ts"
      to: "src/domain/models/Lot.ts"
      via: "Lot type for lot schedule calculation"
      pattern: "import.*Lot.*from"
---

<objective>
Build the bulletproof date calculation engine using TDD (Red-Green-Refactor). This is the core logic of the entire application — every manejo date the user sees flows through these functions. Getting edge cases wrong means wrong dates on the field.

Purpose: TDD ensures the date engine handles all edge cases (leap years, month boundaries, year crossings) correctly before any UI touches it. The tests serve as living documentation of expected behavior.
Output: Fully tested date calculation engine with 100% edge case coverage.
</objective>

<execution_context>
@/home/suporte/.claude/get-shit-done/workflows/execute-plan.md
@/home/suporte/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: RED — Write comprehensive failing tests for the date calculation engine</name>
  <files>
    src/domain/calculations/dateEngine.test.ts
  </files>
  <action>
    Create the test file with all tests written BEFORE any implementation exists. Import from `@/domain/calculations/dateEngine` (file does not exist yet — tests MUST fail).

    Define the ManejoDate shape expected in tests: `{ day: number, date: Date, roundLabel: string }`.

    **Tests for calculateManejoDate(d0: Date, dayOffset: number, roundIndex: number, roundInterval: number): Date**

    Write a `describe("calculateManejoDate", ...)` block with these test cases:
    - Basic: d0=Jan 15 2024, dayOffset=7, roundIndex=0, interval=22 -> Jan 22 2024
    - Basic: d0=Jan 15 2024, dayOffset=9, roundIndex=0, interval=22 -> Jan 24 2024
    - Second round: d0=Jan 15 2024, dayOffset=0, roundIndex=1, interval=22 -> Feb 6 2024
    - Second round with offset: d0=Jan 15 2024, dayOffset=7, roundIndex=1, interval=22 -> Feb 13 2024
    - Fourth round: d0=Jan 15 2024, dayOffset=9, roundIndex=3, interval=22 -> Apr 2 2024
    - Year crossing: d0=Dec 25 2024, dayOffset=9, roundIndex=0, interval=22 -> Jan 3 2025
    - Leap year: d0=Feb 20 2024, dayOffset=9, roundIndex=0, interval=22 -> Feb 29 2024
    - Non-leap year: d0=Feb 20 2023, dayOffset=9, roundIndex=0, interval=22 -> Mar 1 2023
    - Month boundary: d0=Jan 31 2024, dayOffset=0, roundIndex=1, interval=22 -> Feb 22 2024
    - Year boundary exact: d0=Dec 31 2024, dayOffset=1, roundIndex=0, interval=22 -> Jan 1 2025
    - D0 offset (day 0 itself): d0=Jan 15 2024, dayOffset=0, roundIndex=0, interval=22 -> Jan 15 2024

    Formula being tested: `addDays(d0, (roundIndex * roundInterval) + dayOffset)`

    **Tests for calculateProtocolDates(d0: Date, protocol: Protocol, roundCount: number, roundInterval: number): ManejoDate[]**

    Write a `describe("calculateProtocolDates", ...)` block with these test cases:
    - D0-D7-D9, d0=Jan 1 2024, 2 rounds, interval=22:
      -> 6 results: [D0 Jan 1 A1, D7 Jan 8 A1, D9 Jan 10 A1, D0 Jan 23 A2, D7 Jan 30 A2, D9 Feb 1 A2]
      Verify each result has correct day, date, and roundLabel
    - D0-D8-D10, d0=Jan 1 2024, 1 round, interval=22:
      -> 3 results: [D0 Jan 1, D8 Jan 9, D10 Jan 11]
    - D0-D7-D9, d0=Jan 1 2024, 4 rounds, interval=22:
      -> 12 results total, verify last D9 = addDays(Jan 1, 3*22+9) = Apr 5 2024
    - Single round (count=1): returns exactly 3 ManejoDate objects
    - Max rounds (count=6): returns exactly 18 ManejoDate objects
    - Verify ordering: results ordered by round then by day within round
    - Verify roundLabel values: A1, A2, A3, A4 for 4 rounds

    Create Protocol test objects inline using the Protocol type from `@/domain/models`:
    ```
    const protocolD0D7D9: Protocol = { id: 'test-1', name: 'D0-D7-D9', days: [0, 7, 9] as const, isPredefined: true };
    const protocolD0D8D10: Protocol = { id: 'test-2', name: 'D0-D8-D10', days: [0, 8, 10] as const, isPredefined: true };
    ```

    **Tests for calculateLotSchedule(lot: Lot, protocol: Protocol, roundCount: number): ManejoDate[]**

    Write a `describe("calculateLotSchedule", ...)` block with these test cases:
    - Lot with d0=Jan 15, interval=25, protocol D0-D7-D9, 4 rounds:
      -> Uses 25-day interval (NOT default 22)
      -> Verify second round D0 = Jan 15 + 25 = Feb 9
    - Lot with d0=Jan 15, interval=22, protocol D0-D8-D10, 2 rounds:
      -> 6 results with correct D8/D10 offsets
    - Extreme interval (1 day): Should still calculate without error
    - Large interval (30 days) with 6 rounds: Should span many months correctly

    Create Lot test objects inline using the Lot type from `@/domain/models`.

    After writing ALL tests, run `npm test -- --run`. ALL tests MUST FAIL (no implementation exists). This confirms the RED phase.

    Commit: `test(01-03): add failing tests for date calculation engine`
  </action>
  <verify>
    Run: `npm test -- --run` — every test MUST fail (module not found or function not defined). Zero passes expected. This confirms we are in the RED state.
    Verify: test file has >= 15 individual test cases covering all specified edge cases.
  </verify>
  <done>
    dateEngine.test.ts exists with >= 15 test cases covering calculateManejoDate (11 cases including edge cases), calculateProtocolDates (7 cases), and calculateLotSchedule (4 cases). All tests fail because no implementation exists. Committed as RED phase.
  </done>
</task>

<task type="auto">
  <name>Task 2: GREEN + REFACTOR — Implement date engine and barrel export until all tests pass</name>
  <files>
    src/domain/calculations/dateEngine.ts
    src/domain/calculations/index.ts
  </files>
  <action>
    **GREEN phase — implement minimal code to pass all tests:**

    Create src/domain/calculations/dateEngine.ts:

    1. Import addDays from date-fns (per user decision: date-fns for date calculations).
    2. Import Protocol and Lot types from `@/domain/models`.

    3. Define and export `ManejoDate` interface:
       ```typescript
       export interface ManejoDate {
         readonly day: number;
         readonly date: Date;
         readonly roundLabel: string;
       }
       ```

    4. Implement `calculateManejoDate(d0: Date, dayOffset: number, roundIndex: number, roundInterval: number): Date`:
       ```typescript
       export const calculateManejoDate = (d0: Date, dayOffset: number, roundIndex: number, roundInterval: number): Date => {
         return addDays(d0, (roundIndex * roundInterval) + dayOffset);
       };
       ```
       Use ONLY date-fns addDays — NEVER manual date arithmetic (no setDate, no getTime + ms math). This is critical for correct month/year boundary handling.

    5. Implement `calculateProtocolDates(d0: Date, protocol: Protocol, roundCount: number, roundInterval: number): ManejoDate[]`:
       - Iterate roundIndex from 0 to roundCount-1
       - For each round, iterate protocol.days
       - For each day, create ManejoDate with:
         - day: the protocol day value (0, 7, 9, etc.)
         - date: calculateManejoDate(d0, dayValue, roundIndex, roundInterval)
         - roundLabel: `A${roundIndex + 1}`
       - Results are naturally ordered by round then by day (due to iteration order)

    6. Implement `calculateLotSchedule(lot: Lot, protocol: Protocol, roundCount: number): ManejoDate[]`:
       - Convenience wrapper that calls calculateProtocolDates(lot.d0, protocol, roundCount, lot.roundInterval)
       - Uses lot.roundInterval (per-lot interval, per user decision)

    7. Create src/domain/calculations/index.ts:
       - Barrel export: `export { calculateManejoDate, calculateProtocolDates, calculateLotSchedule, type ManejoDate } from './dateEngine';`

    Run `npm test -- --run`. ALL tests MUST PASS. This confirms GREEN phase.
    Commit: `feat(01-03): implement date calculation engine`

    **REFACTOR phase (if needed):**
    - Verify all functions are pure (no side effects, no state mutation, no Date.now() calls)
    - Verify all return types are correct
    - Clean up any code smells
    - Run tests again — still pass
    - If changes made, commit: `refactor(01-03): clean up date engine`
  </action>
  <verify>
    Run: `npm test -- --run` — ALL tests pass with zero failures.
    Run: `npm run type-check` — zero TypeScript errors, dateEngine exports resolve correctly.
    Verify: No manual date arithmetic in dateEngine.ts — only date-fns addDays used (search for setDate, getTime, new Date(d.getTime()) — none should exist).
    Verify: All 3 functions exported from barrel index.ts.
  </verify>
  <done>
    All tests pass (>= 15 test cases, zero failures). calculateManejoDate produces correct dates for all edge cases (year crossing, leap year, month boundary). calculateProtocolDates returns 3*N ManejoDate objects for N rounds, correctly ordered with round labels. calculateLotSchedule uses per-lot interval from Lot object. Functions are pure with no side effects. date-fns addDays is the sole source of date arithmetic. Barrel export works.
  </done>
</task>

</tasks>

<verification>
1. `npm test -- --run` passes ALL tests (edge cases included)
2. `npm run type-check` passes with dateEngine exports
3. Test count >= 15 (covering all specified edge cases)
4. All 3 exported functions work correctly
5. No manual date arithmetic — only date-fns addDays used
</verification>

<success_criteria>
- calculateManejoDate produces correct dates for all edge cases (year crossing, leap year, month boundary)
- calculateProtocolDates returns 3*N ManejoDate objects for N rounds, correctly ordered
- calculateLotSchedule uses per-lot interval from Lot object
- All tests pass with zero failures
- Functions are pure — no side effects, no state mutation
- date-fns addDays is the sole source of date arithmetic
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-03-SUMMARY.md`
</output>
